input = "../.. => .../.../###
#./.. => .../.#./.##
##/.. => .#./.#./...
.#/#. => ###/..#/.##
##/#. => ..#/###/#..
##/## => ..#/#../##.
.../.../... => .##./##../..##/.##.
#../.../... => ##../.#.#/..#./###.
.#./.../... => ##.#/#.#./.#../..##
##./.../... => ...#/##.#/.#.#/#.##
#.#/.../... => ..#./#.../###./...#
###/.../... => #.#./...#/#.#./###.
.#./#../... => ...#/###./.##./...#
##./#../... => ###./####/###./..##
..#/#../... => ####/#.../####/#.##
#.#/#../... => #.##/.#.#/##.#/###.
.##/#../... => ..../.#../.#.#/.##.
###/#../... => ..##/##.#/..##/.###
.../.#./... => ###./..##/.#../#..#
#../.#./... => ###./.#../#.../#...
.#./.#./... => ####/..#./.##./##..
##./.#./... => .#../#.#./###./###.
#.#/.#./... => ####/.##./##.#/.###
###/.#./... => #.#./..##/.##./#...
.#./##./... => ####/#.##/####/..#.
##./##./... => #.../.#../..../#.##
..#/##./... => #..#/..##/#.../####
#.#/##./... => ###./##../..##/#...
.##/##./... => ..../#.##/.###/#.#.
###/##./... => .#../##.#/.#../##..
.../#.#/... => ...#/.###/.##./###.
#../#.#/... => ###./##../#.#./.##.
.#./#.#/... => ..#./.#../.##./.###
##./#.#/... => #.../#.../.##./.#..
#.#/#.#/... => .##./..##/.###/#...
###/#.#/... => ..../####/###./....
.../###/... => #.##/.#.#/#.##/...#
#../###/... => #.../#.#./.#../#...
.#./###/... => ...#/###./.##./.#.#
##./###/... => ##../####/###./#.##
#.#/###/... => ...#/###./##.#/.#.#
###/###/... => #.#./##.#/..../.##.
..#/.../#.. => ...#/..#./..#./##..
#.#/.../#.. => ..#./#.##/#.#./#.##
.##/.../#.. => ####/####/#.##/#...
###/.../#.. => ###./..#./###./.#..
.##/#../#.. => ...#/####/..../###.
###/#../#.. => ##.#/.#../##.#/...#
..#/.#./#.. => ###./#.##/...#/##..
#.#/.#./#.. => #.../..#./..#./#.##
.##/.#./#.. => ##.#/...#/#.#./.###
###/.#./#.. => .#../..##/#.#./..#.
.##/##./#.. => #.../#.#./.###/#...
###/##./#.. => .##./.#../.#.#/.###
#../..#/#.. => ###./#..#/#.../##.#
.#./..#/#.. => #.#./#..#/#.../.###
##./..#/#.. => ...#/..##/..#./####
#.#/..#/#.. => ####/#..#/###./#.#.
.##/..#/#.. => ..#./..#./..../.##.
###/..#/#.. => ...#/#..#/#.#./....
#../#.#/#.. => ..##/.#.#/.###/.##.
.#./#.#/#.. => ..../##.#/..##/#..#
##./#.#/#.. => ..#./..##/#..#/#..#
..#/#.#/#.. => ..#./#.../#.#./##..
#.#/#.#/#.. => ##.#/..##/.###/...#
.##/#.#/#.. => #.##/.##./##../#.#.
###/#.#/#.. => ####/##.#/#..#/#.#.
#../.##/#.. => ..##/#.#./####/####
.#./.##/#.. => ##../###./####/....
##./.##/#.. => .###/####/..#./...#
#.#/.##/#.. => ###./##../##../#.##
.##/.##/#.. => ##../.###/####/.#.#
###/.##/#.. => ##../.##./#.../..#.
#../###/#.. => #.#./.#.#/#.../....
.#./###/#.. => .##./##../...#/##..
##./###/#.. => #.#./..../.##./##.#
..#/###/#.. => ...#/...#/##.#/...#
#.#/###/#.. => .##./.###/#..#/.##.
.##/###/#.. => ####/..##/#.../####
###/###/#.. => ...#/####/..#./.###
.#./#.#/.#. => .##./#.##/.##./.###
##./#.#/.#. => ..##/.#../##.#/###.
#.#/#.#/.#. => .#../..../.#.#/#...
###/#.#/.#. => ###./..#./..../#.#.
.#./###/.#. => #..#/.#../#.../..##
##./###/.#. => .##./...#/.###/....
#.#/###/.#. => .###/###./#.#./.#.#
###/###/.#. => #.##/.#.#/#.#./.##.
#.#/..#/##. => .###/..../####/####
###/..#/##. => #.##/###./..##/.##.
.##/#.#/##. => ..../...#/#..#/..##
###/#.#/##. => #.##/.#../.#../....
#.#/.##/##. => ..##/..##/#.../#..#
###/.##/##. => ##.#/#.../#.##/..##
.##/###/##. => ...#/..#./##../#.##
###/###/##. => #.##/#..#/..#./...#
#.#/.../#.# => ##.#/.#../##.#/.##.
###/.../#.# => #.#./..##/.#.#/##.#
###/#../#.# => ..#./#.##/...#/.###
#.#/.#./#.# => .###/#.##/#..#/#.##
###/.#./#.# => ..../..#./###./..#.
###/##./#.# => .###/##../..##/####
#.#/#.#/#.# => #.#./####/.#../.##.
###/#.#/#.# => ####/..../..##/#...
#.#/###/#.# => #.../.##./#.../...#
###/###/#.# => .#.#/...#/..../..##
###/#.#/### => .#../#.##/#.##/.###
###/###/### => #.../.#.#/#..#/#.##"

rules = {}
rules.default = nil

input.split("\n").each do |l|
  row = l.split(" => ")
  rules[row[0]] = row[1]
end

def rotate(grid)
  lines = grid.split('/')
  ptr = 0
  result = []
  while ptr < lines.length
    ptr += 1
    newl = ""
    lines.each do |l|
      newl += l[lines.length - ptr]
    end
    result << newl
  end
  return result.join('/')
end

def flip(grid)
  newGrid = []
  grid.split('/').each do |g|
    newGrid << g.reverse
  end
  return newGrid.join('/')
end


def splitGrid(size, start)
  grids = []
  start.split('/').each_slice(size) do |rows|
    ptr = 0
    while ptr < rows[0].length
      newGrid = []
      (0..size-1).each do |x|
        newGrid << rows[ptr, size]
      end
      grids << newGrid.join("/")
      ptr += size
    end
  end
  return grids
end

start = ".#./..#/###"

(1..2).each do |iter|
  grids = []

  if (start.split('/').length % 2 == 0)
    grids = splitGrid(2, start)
  else
    grids = splitGrid(3, start)
  end

  afterGrids = []
  grids.each do |g|
    searchSpace = []

    leftg = rotate(g)
    rotations = [g, leftg, g.reverse, leftg.reverse]

    rotations.each do |r|
      searchSpace << r
      searchSpace << flip(r)
    end

    searchSpace.each do |s|
      next if rules[s].nil?

      afterGrids << rules[s]
      break # lazy way of filtering out the duplicates...
    end
  end

  gridSize = Math.sqrt(afterGrids.length).to_i
  answer = []
  afterGrids.each_slice(gridSize) do |rows|
    bigRow = []
    (0..gridSize-1).each do |p|
      bigRow << rows[p]
    end
    answer << bigRow.join
  end

  start = answer.join("/")

  start.split('/').each do |p|
    puts p
  end

  puts ""
end

puts start.scan('#').length
